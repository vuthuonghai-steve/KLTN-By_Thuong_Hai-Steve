#!/usr/bin/env python3
"""
generate_yaml.py — Convert class-mX.md thành YAML Contract

Usage:
    python scripts/generate_yaml.py path/to/class-mX.md
    python scripts/generate_yaml.py class-mX.md --output class-mX.yaml --module M1

Output: YAML Contract với LOCKED header, ghi ra file hoặc stdout

Source: design.md §4 Task 4.3, todo.md Task 4.3 [LOCKED CONTRACT]
Dependencies: pyyaml>=6.0 (pip install pyyaml)
"""

import argparse
import os
import re
import sys
from datetime import datetime
from pathlib import Path

try:
    import yaml
except ImportError:
    print("ERROR: PyYAML chưa được cài. Chạy: pip install pyyaml", file=sys.stderr)
    sys.exit(1)

# Thêm scripts/ vào sys.path để import type_resolver
sys.path.insert(0, str(Path(__file__).parent))
from type_resolver import get_allowed_types, get_mermaid_type


LOCKED_HEADER = """# ⚠️ LOCKED CONTRACT — DO NOT EDIT MANUALLY.
# Generated by Skill 2.5 (class-diagram-analyst). Last updated: {date}
# To update: re-run generate_yaml.py after editing class-mX.md and re-approval at IP2.

"""


def infer_module_from_filename(md_path: str) -> str:
    """Extract module ID từ filename VD: class-m1-auth-profile.md → M1."""
    filename = Path(md_path).stem
    match = re.search(r'class-m(\d+)', filename, re.IGNORECASE)
    if match:
        return f"M{match.group(1)}"
    return "UNKNOWN"


def parse_mermaid_block(content: str) -> list[dict]:
    """
    Parse classDiagram block từ Markdown content.
    Extract: class name, stereotype, fields, methods.
    """
    classes = []

    # Tìm mermaid code block
    mermaid_pattern = r'```mermaid\s*\nclassDiagram\s*\n(.*?)```'
    mermaid_match = re.search(mermaid_pattern, content, re.DOTALL)
    if not mermaid_match:
        return classes

    diagram_content = mermaid_match.group(1)

    # Parse từng class block
    # Format: class ClassName {\n  <<stereotype>>\n  +Type field\n  ...}
    class_pattern = r'class\s+(\w+)\s*\{([^}]*)\}'
    for class_match in re.finditer(class_pattern, diagram_content, re.DOTALL):
        class_name = class_match.group(1)
        class_body = class_match.group(2)

        class_info = {
            'class_name': class_name,
            'slug': _pascal_to_snake(class_name),
            'stereotype': None,
            'fields': [],
            'methods': []
        }

        # Extract stereotype
        stereotype_match = re.search(r'<<(\w+)>>', class_body)
        if stereotype_match:
            class_info['stereotype'] = stereotype_match.group(1)

        # Extract fields và methods
        for line in class_body.strip().split('\n'):
            line = line.strip()
            if not line or line.startswith('<<'):
                continue

            # Method: có dấu ()
            if '()' in line or re.search(r'\w+\(.*\)', line):
                method_match = re.match(r'([+\-#~])(\w+)\s+(\w+)\((.*?)\)', line)
                if method_match:
                    class_info['methods'].append({
                        'visibility': method_match.group(1),
                        'return_type': method_match.group(2),
                        'name': method_match.group(3),
                        'params': method_match.group(4)
                    })
                continue

            # Field: +Type fieldName
            field_match = re.match(r'([+\-#~])(\w+(?:\[\])?)\s+(\w+)', line)
            if field_match:
                visibility = field_match.group(1)
                field_type = field_match.group(2)
                field_name = field_match.group(3)
                class_info['fields'].append({
                    'visibility': visibility,
                    'mermaid_type': field_type,
                    'name': field_name
                })

        classes.append(class_info)

    return classes


def parse_traceability_table(content: str) -> dict:
    """
    Parse Traceability Table từ Markdown để lấy source citations.
    Format: | fieldName | source | assumption |
    Returns: {entity_slug.field_name: {source, assumption}}
    """
    traceability = {}

    # Tìm Traceability Table section
    table_section_pattern = r'## Traceability Table.*?\n(.*?)(?=\n##|\Z)'
    section_match = re.search(table_section_pattern, content, re.DOTALL | re.IGNORECASE)
    if not section_match:
        return traceability

    table_content = section_match.group(1)

    # Parse table rows
    row_pattern = r'\|\s*`?(\w+)`?\s*\|\s*`?(\w+)`?\s*\|\s*([^|]+)\|\s*([^|]*)\|'
    for row_match in re.finditer(row_pattern, table_content):
        entity = row_match.group(1)
        field = row_match.group(2)
        source = row_match.group(3).strip()
        assumption_flag = row_match.group(4).strip()

        key = f"{entity}.{field}"
        traceability[key] = {
            'source': source,
            'assumption': 'ASSUMPTION' in assumption_flag or assumption_flag == '[x]'
        }

    return traceability


def build_yaml_contract(
    classes: list[dict],
    traceability: dict,
    module_id: str,
    md_path: str
) -> dict:
    """Build YAML Contract dict từ parsed classes và traceability."""

    # Module name mapping
    module_names = {
        'M1': 'Auth & Profile',
        'M2': 'Content Engine',
        'M3': 'Discovery Feed',
        'M4': 'Engagement & Connections',
        'M5': 'Bookmarking',
        'M6': 'Notifications & Moderation',
    }

    contract = {
        'meta': {
            'module': module_id,
            'module_name': module_names.get(module_id, module_id),
            'skill_version': '2.5',
            'generated_at': datetime.now().strftime('%Y-%m-%d'),
            'sources_consumed': [
                'Docs/life-2/diagrams/er-diagram.md',
                f'Docs/life-2/diagrams/activity-diagrams/',
                f'Docs/life-2/diagrams/UseCase/',
            ]
        },
        'entities': [],
        'validation_report': {
            'total_fields': 0,
            'fields_with_source': 0,
            'fields_as_assumption': 0,
            'unresolved': []
        }
    }

    allowed_types = get_allowed_types()
    total_fields = 0
    fields_with_source = 0
    fields_as_assumption = 0

    for cls in classes:
        entity_slug = cls['slug']
        is_collection = cls.get('stereotype') == 'Collection'
        is_value_object = cls.get('stereotype') == 'ValueObject'
        is_embedded = cls.get('stereotype') == 'EmbeddedDoc'

        entity = {
            'slug': entity_slug,
            'display_name': cls['class_name'],
            'payload_collection': entity_slug if is_collection else None,
            'aggregate_root': is_collection and not is_embedded,
            'stereotype': cls.get('stereotype'),
            'fields': [],
            'behaviors': [],
            'access_control': {},
            'assumptions': []
        }

        for field_info in cls['fields']:
            field_name = field_info['name']

            # Map mermaid type → payload type (approximation)
            mermaid_to_payload = {
                'String': 'text', 'Number': 'number', 'Boolean': 'boolean',
                'DateTime': 'date', 'ObjectId': 'relationship', 'JSON': 'json',
                'Float': 'number', 'Object': 'group'
            }
            field_type = mermaid_to_payload.get(
                field_info['mermaid_type'].rstrip('[]'), 'text'
            )

            # Lấy source từ traceability table
            trace_key = f"{entity_slug}.{field_name}"
            trace_info = traceability.get(trace_key, {})
            source = trace_info.get('source', '')
            is_assumption = trace_info.get('assumption', False)

            field = {
                'name': field_name,
                'type': field_type,
                'required': field_info['visibility'] == '+',
                'source': source if source else '[MISSING — cần bổ sung]',
            }

            if is_assumption:
                field['assumption'] = True
                entity['assumptions'].append(field_name)
                fields_as_assumption += 1

            entity['fields'].append(field)
            total_fields += 1
            if source:
                fields_with_source += 1

        contract['entities'].append(entity)

    contract['validation_report'] = {
        'total_fields': total_fields,
        'fields_with_source': fields_with_source,
        'fields_as_assumption': fields_as_assumption,
        'unresolved': []
    }

    return contract


def _pascal_to_snake(name: str) -> str:
    """Convert PascalCase sang snake_case. VD: BookmarkCollection → bookmark_collections."""
    # Insert underscore trước uppercase letters
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    result = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
    return result


def main():
    parser = argparse.ArgumentParser(
        description='Convert class-mX.md sang YAML Contract (LOCKED format)'
    )
    parser.add_argument('md_path', help='Path đến class-mX.md')
    parser.add_argument('--output', default=None, help='Output YAML path (default: same dir as md)')
    parser.add_argument('--module', default=None, help='Module ID: M1, M2... (auto-detect từ filename nếu không chỉ định)')
    args = parser.parse_args()

    if not os.path.exists(args.md_path):
        print(f"ERROR: File không tìm thấy: {args.md_path}", file=sys.stderr)
        sys.exit(1)

    with open(args.md_path, encoding='utf-8') as f:
        content = f.read()

    # Detect module
    module_id = args.module or infer_module_from_filename(args.md_path)

    # Parse diagram
    classes = parse_mermaid_block(content)
    if not classes:
        print("WARNING: Không tìm thấy classDiagram block trong file", file=sys.stderr)

    # Parse traceability
    traceability = parse_traceability_table(content)

    # Build contract
    contract = build_yaml_contract(classes, traceability, module_id, args.md_path)

    # Determine output path
    if args.output:
        output_path = args.output
    else:
        md_path_obj = Path(args.md_path)
        output_path = str(md_path_obj.parent / (md_path_obj.stem + '.yaml'))

    # Write YAML với LOCKED header
    yaml_content = yaml.dump(
        contract,
        default_flow_style=False,
        allow_unicode=True,
        sort_keys=False
    )

    header = LOCKED_HEADER.format(date=datetime.now().strftime('%Y-%m-%d'))

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header)
        f.write(yaml_content)

    print(f"✅ YAML Contract generated: {output_path}")
    print(f"   Entities: {len(contract['entities'])}")
    print(f"   Total fields: {contract['validation_report']['total_fields']}")
    print(f"   Fields with source: {contract['validation_report']['fields_with_source']}")
    print(f"   Assumptions: {contract['validation_report']['fields_as_assumption']}")


if __name__ == '__main__':
    main()
